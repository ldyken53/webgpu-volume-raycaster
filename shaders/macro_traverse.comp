#version 450 core

#define FLT_MAX ( 3.402823466e+38f )

layout(set = 0, binding = 1, std430) buffer BlockRanges
{
    vec2 block_ranges[];
};

layout(set = 0, binding = 4) uniform VolumeParams {
	ivec3 volume_dims;
    float isovalue;
    vec3 volume_scale;
    uint image_width;
};

layout(set = 0, binding = 0, std140) uniform ViewParams {
    mat4 proj_view;
    vec4 eye_pos;
};

struct RayInfo {
    uint block_id;
    vec3 ray_dir;
    float t;
}

layout(set = 0, binding = 1, std430) buffer RayInformation {
    RayInfo rays[];
};

bool outside_dual_grid(const vec3 p) {
    return any(lessThan(p, vec3(0))) || any(greaterThanEqual(p, vec3(volume_dims - 1)));
}

const ivec3 index_to_vertex[8] = {
    ivec3(0, 0, 0), // v000 = 0
    ivec3(1, 0, 0), // v100 = 1
    ivec3(0, 1, 0), // v010 = 2
    ivec3(1, 1, 0), // v110 = 3
    ivec3(0, 0, 1), // v001 = 4
    ivec3(1, 0, 1), // v101 = 5
    ivec3(0, 1, 1), // v011 = 6
    ivec3(1, 1, 1)  // v111 = 7
};

void main() {
    RayInfo ray_info = rays[gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * image_width];

    if (ray_info.t == FLT_MAX) {
        return;
    }

    // Transform the ray into the dual grid space
    vec3 volume_translation = vec3(0) - volume_scale * 0.5;
	vec3 transformed_eye = (eye_pos.xyz - volume_translation) / volume_scale;
	const vec3 vol_eye = transformed_eye * volume_dims - vec3(0.5);
    const vec3 grid_ray_dir = normalize(ray_info.ray_dir * volume_dims);

	vec3 p = (vol_eye + ray_info.t * grid_ray_dir);
    p = clamp(p, vec3(0), vec3(volume_dims - 2));
    const vec3 inv_grid_ray_dir = 1.0 / grid_ray_dir;
    const vec3 start_cell = floor(p);
    const vec3 t_max_neg = (start_cell - vol_eye) * inv_grid_ray_dir;
    const vec3 t_max_pos = (start_cell + vec3(1) - vol_eye) * inv_grid_ray_dir;
    const bvec3 is_neg_dir = lessThan(grid_ray_dir, vec3(0));
    // Pick between positive/negative t_max based on the ray sign
    vec3 t_max = mix(t_max_pos, t_max_neg, is_neg_dir);
    const ivec3 grid_step = ivec3(sign(grid_ray_dir));
    // Note: each voxel is a 1^3 box on the grid
    const vec3 t_delta = abs(inv_grid_ray_dir);

    /* Note: For isosurface rendering we want to be traversing the dual grid,
     * where values are at the cell vertices. This traverses the cell-centered
     * grid where values are at cell centers. Switching to the dual grid just
     * is an additional -0.5 offset in voxel space (shifting by 0.5 grid cells down)
     */

    float t_prev = ray_info.t;
    float vertex_values[8];
    vec2 cell_range;
    color = vec4(0);
    // Traverse the grid 
    while (!outside_dual_grid(p) && color.a <= 0.99) {
        const ivec3 v000 = ivec3(p);
        load_vertex_values(v000, vertex_values, cell_range);

        // Simple rule of signs isosurface within the cell. First compute
        // the field value at the ray's enter and exit points
        const float t_next = min(t_max.x, min(t_max.y, t_max.z));

        bool skip_cell = false;
#if !SHOW_VOLUME
        // Skip cells that we know don't contain the surface
        skip_cell = isovalue < cell_range.x || isovalue > cell_range.y;
#endif

        if (!skip_cell) {
#if USE_POLYNOMIAL
            // The text seems to not say explicitly, but I think it is required to have
            // the ray "origin" within the cell for the cell-local coordinates for a to
            // be computed properly. So here I set the cell_p to be at the midpoint of the
            // ray's overlap with the cell, which makes it easy to compute t_in/t_out and
            // avoid numerical issues with cell_p being right at the edge of the cell.
            const vec3 cell_p = vol_eye + grid_ray_dir * (t_prev + (t_next - t_prev) * 0.5f);
            float t_in = -(t_next - t_prev) * 0.5f;
            float t_out = (t_next - t_prev) * 0.5f;
            const vec4 poly = compute_polynomial(cell_p, grid_ray_dir, v000, vertex_values);

            float f_in = evaluate_polynomial(poly, t_in);
            float f_out = evaluate_polynomial(poly, t_out);

#else
            // Non-polynomial mode, just do trilinear interpolation
            const vec3 p_enter = vol_eye + grid_ray_dir * t_prev;
            float f_in = trilinear_interpolate_in_cell(p_enter, v000, vertex_values) - isovalue;

            const vec3 p_exit = vol_eye + grid_ray_dir * t_next;
            float f_out = trilinear_interpolate_in_cell(p_exit, v000, vertex_values) - isovalue;
#endif

            vec4 val_color = vec4(0);
#if MARMITT
            float roots[2] = {0, 0};
            // TODO: Seeming to get some holes in the surface with the Marmitt intersector
            if (solve_quadratic(vec3(3.f * poly.x, 2.f * poly.y, poly.z), roots)) {
                if (roots[0] >= t_in && roots[0] <= t_out) {
                    float f_root0 = evaluate_polynomial(poly, roots[0]);
                    if (sign(f_root0) == sign(f_in)) {
                        t_in = roots[0];
                        f_in = f_root0;
                    } else {
                        t_out = roots[0];
                        f_out = f_root0;
                    }
                }
                if (roots[1] >= t_in && roots[1] <= t_out) {
                    float f_root1 = evaluate_polynomial(poly, roots[1]);
                    if (sign(f_root1) == sign(f_in)) {
                        t_in = roots[1];
                        f_in = f_root1;
                    } else {
                        t_out = roots[1];
                        f_out = f_root1;
                    }
                }
            }
            // If the signs aren't equal we know there's an intersection in the cell
            if (sign(f_in) != sign(f_out)) {
                // Find the intersection via repeated linear interpolation
                for (int i = 0; i < 2; i++) {
                    float t = t_in + (t_out - t_in) * (-f_in) / (f_out - f_in);
                    float f_t = evaluate_polynomial(poly, t);
                    if (sign(f_t) == sign(f_in)) {
                        t_in = t;
                        f_in = f_t;
                    } else {
                        t_out = t;
                        f_out = f_t;
                    }
                }
                float t_hit = t_in + (t_out - t_in) * (-f_in) / (f_out - f_in);
                // This t_hit value is relative to cell_p, so now find the depth
                // along the original ray
                vec3 hit_p = cell_p + grid_ray_dir * t_hit;
#if GRADIENT_SHADING
				vec3 sample1 = vec3(trilinear_interpolate_in_cell(hit_p-vec3(0.01, 0, 0), v000, vertex_values), 
					trilinear_interpolate_in_cell(hit_p-vec3(0, 0.01, 0), v000, vertex_values),
					trilinear_interpolate_in_cell(hit_p-vec3(0, 0, 0.01), v000, vertex_values));
				vec3 sample2 = vec3(trilinear_interpolate_in_cell(hit_p+vec3(0.01, 0, 0), v000, vertex_values), 
					trilinear_interpolate_in_cell(hit_p+vec3(0, 0.01, 0), v000, vertex_values),
					trilinear_interpolate_in_cell(hit_p+vec3(0, 0, 0.01), v000, vertex_values));
				vec3 N = normalize(sample2-sample1);
				vec3 L = normalize(vec3(255,0,200)-grid_ray_dir);
				vec3 V = normalize(vol_eye-grid_ray_dir);
				val_color.xyz += shading(N, V, L);
#else

                t_hit = length(hit_p - vol_eye);
                // Apply some scaling factor so the depth values are within [0, 1]
                // to be displayed as a color. Here I'm just dividing by the volume
                // dimensions to scale it
                val_color.xyz = vec3(t_hit) / length(volume_dims);
#endif
                val_color.w = 1;
            }
#else
            if (sign(f_in) != sign(f_out)) {
                val_color = vec4(1);
            }
#endif
#if SHOW_VOLUME
            else {
				// Have to add two * isovalue because f_in, f_out have isovalue subtracted from them for isosurface extraction
                float val = (f_in + f_out + 2 * isovalue) * 0.5f;
                val_color = vec4(textureLod(sampler2D(colormap, mySampler), vec2(val, 0.5), 0.f).rgb, val * 0.5);
                // Opacity correction applied to the val_color.a to account for
                // variable interval of ray overlap with each cell
                val_color.a = clamp(1.f - pow(1.f - val_color.a, t_next - t_prev), 0.f, 1.f);
            }
#endif
            color.rgb += (1.0 - color.a) * val_color.a * val_color.rgb;
            color.a += (1.0 - color.a) * val_color.a;
        }

        t_prev = t_next;
        // Advance in the grid
        if (t_next == t_max.x) {
            p.x += grid_step.x;
            t_max.x += t_delta.x;
        } else if (t_next == t_max.y) {
            p.y += grid_step.y;
            t_max.y += t_delta.y;
        } else {
            p.z += grid_step.z;
            t_max.z += t_delta.z;
        }
    }
}


